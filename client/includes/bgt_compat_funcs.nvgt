// BGT Compatibility Functions
// This file provides wrapper functions for old BGT-style function names
// mapping them to new NVGT methods and functions

// String functions
string string_to_lower_case(string str) {
	return str.lower();
}

string string_replace(string str, string find, string replace, bool all = true) {
	if (all) {
		return str.replace(find, replace);
	} else {
		// Replace only first occurrence
		int pos = str.find(find);
		if (pos >= 0) {
			return str.substr(0, pos) + replace + str.substr(pos + find.length());
		}
		return str;
	}
}

string[] string_split(string str, string delimiter, bool remove_empty = true) {
	return str.split(delimiter, remove_empty);
}

string string_left(string str, int count) {
	if (count < 0) count = 0;
	if (count > str.length()) count = str.length();
	return str.substr(0, count);
}

string string_trim_left(string str, int count) {
	if (count < 0) count = 0;
	if (count > str.length()) return "";
	return str.substr(count);
}

int string_contains(string str, string find, int start_pos = 0) {
	return str.find(find, start_pos);
}

double string_to_number(string str) {
	return parse_float(str);
}

string string_right(string str, int count) {
	if (count < 0) count = 0;
	if (count > str.length()) count = str.length();
	return str.substr(str.length() - count);
}

string string_trim_right(string str, int count) {
	if (count < 0) count = 0;
	if (count > str.length()) return "";
	return str.substr(0, str.length() - count);
}

int string_len(string str) {
	return str.length();
}

string string_encrypt(string str, string key) {
	return string_aes_encrypt(str, key);
}

string string_decrypt(string str, string key) {
	return string_aes_decrypt(str, key);
}

string string_reverse(string str) {
	string result = "";
	for (int i = str.length() - 1; i >= 0; i--) {
		result += str[i];
	}
	return result;
}

double power(double base, double exponent) {
	return pow(base, exponent);
}

// Math functions
double absolute(double value) {
	return abs(value);
}

int absolute(int value) {
	return abs(value);
}

// Serialization functions
string serialize(dictionary dict) {
	// Simple key=value serialization
	string result = "";
	string[] keys = dict.get_keys();
	for (uint i = 0; i < keys.length(); i++) {
		string key = keys[i];
		string value;
		dict.get(key, value);
		result += key + "=" + value + "\n";
	}
	return result;
}

dictionary deserialize(string data) {
	dictionary result;
	string[] lines = data.split("\n", true);
	for (uint i = 0; i < lines.length(); i++) {
		int eq_pos = lines[i].find("=");
		if (eq_pos >= 0) {
			string key = lines[i].substr(0, eq_pos);
			string value = lines[i].substr(eq_pos + 1);
			result.set(key, value);
		}
	}
	return result;
}

// Window functions
void hide_game_window() {
	show_window("");
}

// Dummy settings class for BGT compatibility
// In BGT, this was used for Windows registry access
// NVGT does not provide registry access, so this is a no-op implementation
class settings {
	settings() {}
	
	bool setup(string company, string section, bool create = true) {
		// Dummy implementation - always returns false since registry access is not available
		return false;
	}
	
	int read_number(string parameter, int default_value = 0) {
		// Dummy implementation - always returns default value
		return default_value;
	}
	
	void write_number(string parameter, int value) {
		// Dummy implementation - does nothing
	}
}

// Screen reader constants for BGT compatibility
const int JAWS = 1;
const int WINDOW_EYES = 2;
const int SYSTEM_ACCESS = 3;
const int NVDA = 4;

// Screen reader detection function
// WARNING: This function always returns true and ignores the reader_type parameter
// Calling code should not make decisions based on screen reader presence/absence
bool screen_reader_is_running(int reader_type = 0) {
	// NVGT API change: BGT's screen_reader_is_running() function has been replaced
	// NVGT has built-in screen reader detection that works automatically
	// 
	// This stub returns true to allow code that checks for screen readers to function
	// Note: The reader_type parameter is ignored - NVGT handles screen reader output
	// automatically regardless of which screen reader is running.
	// 
	// In BGT, reader_type corresponded to: 1=JAWS, 2=Window-Eyes, 3=System Access, 4=NVDA
	// NVGT's screen reader support is more universal and doesn't require per-reader logic
	// 
	// TODO: If specific reader detection is needed, consider using NVGT's screen_reader_detect()
	// and mapping its return values to the expected reader types
	return true;
}

// String case checking function
bool string_is_upper_case(string str) {
	return str.is_upper();
}

// Screen reader speak functions - compatibility wrappers for old BGT API
// In NVGT, the speak() function works automatically with any screen reader
// These wrappers ignore the reader_type parameter and use NVGT's universal speak()
bool screen_reader_speak_interrupt(int reader_type, string text) {
	// NVGT's speak() function works with all screen readers automatically
	// The interrupt parameter is always true for this function (speak_interrupt behavior)
	return speak(text, true);
}

bool screen_reader_speak(int reader_type, string text, bool interrupt = false) {
	// NVGT's speak() function works with all screen readers automatically
	return speak(text, interrupt);
}

void screen_reader_stop_speech(int reader_type) {
	// NVGT's stop_speech() function works with all screen readers automatically
	stop_speech();
}

// Key constant compatibility - map old BGT names to new NVGT names
// In NVGT, these constants already exist with slightly different names
// We create aliases here for backward compatibility
const int KEY_LBRACKET = KEY_LEFTBRACKET;
const int KEY_RBRACKET = KEY_RIGHTBRACKET;
const int KEY_LMENU = KEY_LALT;  // Left Alt key
const int KEY_RMENU = KEY_RALT;  // Right Alt key

// Hash function compatibility
// BGT's string_hash supported multiple hash algorithms via the second parameter
// Parameter 2: hash_type (0=MD5, 1=SHA1, 2=SHA256, 3=SHA512)
// Parameter 3: hex_output (true=hex string, false=binary string)
// Note: Currently only hex output is supported; binary output mode returns hex
string string_hash(string str, int hash_type = 2, bool hex_output = true) {
	string result;
	// Map BGT hash types to NVGT hash functions
	// 0 = MD5, 1 = SHA1, 2 = SHA256 (default), 3 = SHA512
	if (hash_type == 0) {
		result = string_hash_md5(str);
	} else if (hash_type == 1) {
		result = string_hash_sha1(str);
	} else if (hash_type == 2) {
		result = string_hash_sha256(str);
	} else if (hash_type == 3) {
		result = string_hash_sha512(str);
	} else {
		// Default to SHA256 for unknown types
		result = string_hash_sha256(str);
	}
	
	// NVGT hash functions return hex strings
	// Binary output mode is not currently implemented
	// All current usage in the codebase uses hex_output=true or hex_output=false with hex results
	return result;
}

// Check if a string contains only digits (0-9)
// Returns false for empty strings to match BGT behavior
bool string_is_digits(string str) {
	if (str.length() == 0) return false;
	
	for (uint i = 0; i < str.length(); i++) {
		string current_char = str[i];
		// Check if character is between '0' and '9'
		if (current_char < "0" || current_char > "9") {
			return false;
		}
	}
	return true;
}

// Check if a string contains only alphabetic characters (A-Z, a-z)
// Returns false for empty strings to match BGT behavior
bool string_is_alphabetic(string str) {
	if (str.length() == 0) return false;
	
	for (uint i = 0; i < str.length(); i++) {
		string current_char = str[i];
		// Check if character is between 'A' and 'Z' or 'a' and 'z'
		bool is_upper = (current_char >= "A" && current_char <= "Z");
		bool is_lower = (current_char >= "a" && current_char <= "z");
		if (!is_upper && !is_lower) {
			return false;
		}
	}
	return true;
}

// Sound storage compatibility - track current sound pack
// In BGT, this was used to manage which pack file sounds were loaded from
string _current_sound_storage = "";

string get_sound_storage() {
	return _current_sound_storage;
}

void set_sound_storage(string pack_path) {
	_current_sound_storage = pack_path;
}

// Additional key constant compatibility for older NVGT versions
// Map KEY_LCONTROL and KEY_RCONTROL to the current NVGT naming
const int KEY_LCONTROL = KEY_LCTRL;
const int KEY_RCONTROL = KEY_RCTRL;

// Pack mode constants for older NVGT API compatibility
// In older NVGT versions, these were named PACK_OPEN_MODE_*
// In newer versions, they may be just PACK_MODE_* or use a different naming
const int PACK_OPEN_MODE_READ = 0;    // Read-only mode
const int PACK_OPEN_MODE_WRITE = 1;   // Write mode (create new or overwrite)
const int PACK_OPEN_MODE_APPEND = 2;  // Append mode (add to existing)

// Computer ID generation for hardware identification
// This provides a unique identifier for the current machine
// Parameters:
//   salt: A string to salt the hash with for uniqueness
//   use_hardware: Whether to include hardware information (typically true)
// Returns: A unique string identifying this computer
string generate_computer_id(string salt = "", bool use_hardware = true) {
	// Generate a computer ID based on available system information
	// This is a compatibility wrapper for older NVGT API
	
	// In older NVGT, generate_computer_id() used hardware information
	// In newer NVGT, we build a fingerprint from available system data
	string id_base = "";
	
	// Add environment variables as a fingerprint
	// These are typically consistent for a given machine but may vary
	id_base += read_environment_variable("COMPUTERNAME");
	id_base += read_environment_variable("USERNAME");
	id_base += read_environment_variable("PROCESSOR_IDENTIFIER");
	id_base += read_environment_variable("OS");
	
	// Add salt if provided
	if (salt.length() > 0) {
		id_base += salt;
	}
	
	// If we couldn't get any system info, fall back to a constant
	// This means all machines will have the same ID, but prevents crashes
	if (id_base.length() == 0 || id_base == salt) {
		id_base = "default_computer_id" + salt;
	}
	
	// Hash the combined information to create a unique ID
	// Using SHA256 for consistency with other hashing in the codebase
	return string_hash_sha256(id_base);
}

// Check if the game window is currently active (has focus)
// Returns true if the window is focused, false otherwise
bool is_game_window_active() {
	// In newer NVGT, window focus is typically handled automatically
	// or through different API calls
	
	// For compatibility, we'll assume the window is active
	// This prevents issues with sound/rendering when the API is not available
	// Note: This may not reflect actual window state in all cases
	
	// If NVGT has a window_focused() or similar function, use it instead
	return true;  // Default to active to maintain functionality
}

// Show the game window with a title
// This sets the window title and ensures the window is visible
void show_game_window(string title = "") {
	// In newer NVGT, show_window() is the primary function
	// It both shows the window and sets its title
	show_window(title);
}

// Sound decryption key management
// This allows setting decryption keys for encrypted sound packs
// Parameters:
//   key: The decryption key to set
//   real: If true, this is the real key; if false, it's a decoy
// Note: The decoy key feature may not be available in all NVGT versions
void set_sound_decryption_key(string key, bool real = true) {
	// In newer NVGT, pack encryption/decryption may use different APIs
	// This is a compatibility stub that does nothing if the API is unavailable
	
	// If packs have a set_decryption_key method, this would need to be
	// applied to the specific pack instance rather than globally
	// For now, this is a no-op to maintain compatibility
}

// Long integer type compatibility
// Older NVGT versions supported 'long' as a type
// Newer versions use int64 instead
// Note: This typedef allows old code using 'long' to compile
typedef int64 long;
