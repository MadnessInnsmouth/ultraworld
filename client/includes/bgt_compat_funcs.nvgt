// BGT Compatibility Functions
// This file provides wrapper functions for old BGT-style function names
// mapping them to new NVGT methods and functions

// String functions
string string_to_lower_case(string str) {
	return str.lower();
}

string string_replace(string str, string find, string replace, bool all = true) {
	if (all) {
		return str.replace(find, replace);
	} else {
		// Replace only first occurrence
		int pos = str.find(find);
		if (pos >= 0) {
			return str.substr(0, pos) + replace + str.substr(pos + find.length());
		}
		return str;
	}
}

string[] string_split(string str, string delimiter, bool remove_empty = true) {
	return str.split(delimiter, remove_empty);
}

string string_left(string str, int count) {
	if (count < 0) count = 0;
	if (count > str.length()) count = str.length();
	return str.substr(0, count);
}

string string_trim_left(string str, int count) {
	if (count < 0) count = 0;
	if (count > str.length()) return "";
	return str.substr(count);
}

int string_contains(string str, string find, int start_pos = 0) {
	return str.find(find, start_pos);
}

double string_to_number(string str) {
	return parse_float(str);
}

string string_right(string str, int count) {
	if (count < 0) count = 0;
	if (count > str.length()) count = str.length();
	return str.substr(str.length() - count);
}

string string_trim_right(string str, int count) {
	if (count < 0) count = 0;
	if (count > str.length()) return "";
	return str.substr(0, str.length() - count);
}

int string_len(string str) {
	return str.length();
}

string string_encrypt(string str, string key) {
	return string_aes_encrypt(str, key);
}

string string_decrypt(string str, string key) {
	return string_aes_decrypt(str, key);
}

string string_reverse(string str) {
	string result = "";
	for (int i = str.length() - 1; i >= 0; i--) {
		result += str[i];
	}
	return result;
}

double power(double base, double exponent) {
	return pow(base, exponent);
}

// Math functions
double absolute(double value) {
	return abs(value);
}

int absolute(int value) {
	return abs(value);
}

// Serialization functions
string serialize(dictionary dict) {
	// Simple key=value serialization
	string result = "";
	string[] keys = dict.get_keys();
	for (uint i = 0; i < keys.length(); i++) {
		string key = keys[i];
		string value;
		dict.get(key, value);
		result += key + "=" + value + "\n";
	}
	return result;
}

dictionary deserialize(string data) {
	dictionary result;
	string[] lines = data.split("\n", true);
	for (uint i = 0; i < lines.length(); i++) {
		int eq_pos = lines[i].find("=");
		if (eq_pos >= 0) {
			string key = lines[i].substr(0, eq_pos);
			string value = lines[i].substr(eq_pos + 1);
			result.set(key, value);
		}
	}
	return result;
}

// Window functions
void hide_game_window() {
	show_window("");
}

// Dummy settings class for BGT compatibility
// In BGT, this was used for Windows registry access
// NVGT does not provide registry access, so this is a no-op implementation
class settings {
	settings() {}
	
	bool setup(string company, string section, bool create = true) {
		// Dummy implementation - always returns false since registry access is not available
		return false;
	}
	
	int read_number(string parameter, int default_value = 0) {
		// Dummy implementation - always returns default value
		return default_value;
	}
	
	void write_number(string parameter, int value) {
		// Dummy implementation - does nothing
	}
}

// Screen reader constants for BGT compatibility
const int JAWS = 1;
const int WINDOW_EYES = 2;
const int SYSTEM_ACCESS = 3;
const int NVDA = 4;

// Screen reader detection function
// WARNING: This function always returns true and ignores the reader_type parameter
// Calling code should not make decisions based on screen reader presence/absence
bool screen_reader_is_running(int reader_type = 0) {
	// NVGT API change: BGT's screen_reader_is_running() function has been replaced
	// NVGT has built-in screen reader detection that works automatically
	// 
	// This stub returns true to allow code that checks for screen readers to function
	// Note: The reader_type parameter is ignored - NVGT handles screen reader output
	// automatically regardless of which screen reader is running.
	// 
	// In BGT, reader_type corresponded to: 1=JAWS, 2=Window-Eyes, 3=System Access, 4=NVDA
	// NVGT's screen reader support is more universal and doesn't require per-reader logic
	// 
	// TODO: If specific reader detection is needed, consider using NVGT's screen_reader_detect()
	// and mapping its return values to the expected reader types
	return true;
}

// String case checking function
bool string_is_upper_case(string str) {
	return str.is_upper();
}

// Screen reader speak functions - compatibility wrappers for old BGT API
// In NVGT, the speak() function works automatically with any screen reader
// These wrappers ignore the reader_type parameter and use NVGT's universal speak()
bool screen_reader_speak_interrupt(int reader_type, string text) {
	// NVGT's speak() function works with all screen readers automatically
	// The interrupt parameter is always true for this function (speak_interrupt behavior)
	return speak(text, true);
}

bool screen_reader_speak(int reader_type, string text, bool interrupt = false) {
	// NVGT's speak() function works with all screen readers automatically
	return speak(text, interrupt);
}

void screen_reader_stop_speech(int reader_type) {
	// NVGT's stop_speech() function works with all screen readers automatically
	stop_speech();
}

// Key constant compatibility - map old BGT names to new NVGT names
// In NVGT, these constants already exist with slightly different names
// We create aliases here for backward compatibility
const int KEY_LBRACKET = KEY_LEFTBRACKET;
const int KEY_RBRACKET = KEY_RIGHTBRACKET;
const int KEY_LMENU = KEY_LALT;  // Left Alt key
const int KEY_RMENU = KEY_RALT;  // Right Alt key

// Hash function compatibility
// BGT's string_hash supported multiple hash algorithms via the second parameter
// Parameter 2: hash_type (0=MD5, 1=SHA1, 2=SHA256, 3=SHA512)
// Parameter 3: hex_output (true=hex string, false=binary string)
// Note: Currently only hex output is supported; binary output mode returns hex
string string_hash(string str, int hash_type = 2, bool hex_output = true) {
	string result;
	// Map BGT hash types to NVGT hash functions
	// 0 = MD5, 1 = SHA1, 2 = SHA256 (default), 3 = SHA512
	if (hash_type == 0) {
		result = string_hash_md5(str);
	} else if (hash_type == 1) {
		result = string_hash_sha1(str);
	} else if (hash_type == 2) {
		result = string_hash_sha256(str);
	} else if (hash_type == 3) {
		result = string_hash_sha512(str);
	} else {
		// Default to SHA256 for unknown types
		result = string_hash_sha256(str);
	}
	
	// NVGT hash functions return hex strings
	// Binary output mode is not currently implemented
	// All current usage in the codebase uses hex_output=true or hex_output=false with hex results
	return result;
}

// Check if a string contains only digits (0-9)
// Returns false for empty strings to match BGT behavior
bool string_is_digits(string str) {
	if (str.length() == 0) return false;
	
	for (uint i = 0; i < str.length(); i++) {
		string current_char = str[i];
		// Check if character is between '0' and '9'
		if (current_char < "0" || current_char > "9") {
			return false;
		}
	}
	return true;
}

// Sound storage compatibility - track current sound pack
// In BGT, this was used to manage which pack file sounds were loaded from
string _current_sound_storage = "";

string get_sound_storage() {
	return _current_sound_storage;
}

void set_sound_storage(string pack_path) {
	_current_sound_storage = pack_path;
}
